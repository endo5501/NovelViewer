## Context

縦書き表示のカラム分割は `vertical_text_viewer.dart` の `_splitLineIntoColumns` → `_addPlainTextToColumns` / `_addRubyTextToColumns` で行われている。現在は純粋に文字数（`charsPerColumn`）のみで分割しており、日本語組版の禁則処理が未実装。

カラム分割は `TextSegment`（`PlainTextSegment` / `RubyTextSegment`）のリストを受け取り、各セグメントを順次処理してカラム（列）を構築する。禁則判定には「次のカラムの先頭文字」や「現在のカラムの末尾文字」を参照する必要があるが、現在のストリーム処理方式ではセグメント境界をまたぐ先読みが困難。

## Goals / Non-Goals

**Goals:**

- 行頭禁則文字（句読点、閉じ括弧など）がカラムの先頭に来ないようにする
- 行末禁則文字（開き括弧など）がカラムの末尾に来ないようにする
- 禁則文字の定義をデータレイヤーに分離し、テスト可能にする
- 既存のページネーション（幅ベースパッキング）との整合性を維持する

**Non-Goals:**

- ぶら下げ組み（文字をはみ出させて配置する視覚的処理）は対象外。文字数の調整のみ行う
- 文字間の詰め処理（カーニング調整）は対象外
- 分離禁止（特定の文字列を分割しない処理）は対象外
- 横書きモードへの禁則処理適用は対象外（Flutterの標準テキストレイアウトが処理）

## Decisions

### 1. 禁則処理方式：追い出し（行頭禁則文字を前のカラムに含める）

**選択**: 行頭禁則文字が次のカラムの先頭に来る場合、その文字を現在のカラムの末尾に追加する（カラムが1文字長くなる）。行末禁則文字が現在のカラムの末尾に来る場合、その文字を次のカラムの先頭に移動する（カラムが1文字短くなる）。

**代替案**:
- ぶら下げ方式（文字を視覚的にはみ出させる）: Wrap widgetベースのレイアウトでは実現が複雑で、ページネーション幅計算にも影響する
- 追い込み方式（前の行の文字間を詰めて吸収する）: 個別Text widgetレイアウトでは字間調整が困難

**理由**: 追い出しは最もシンプルで、既存のデータ構造（`List<TextSegment>` のカラムリスト）をそのまま活用できる。カラムの文字数が1文字前後するだけで、Wrapレイアウトやページネーションへの影響が最小限。

### 2. 実装方式：フラット文字リスト化 + 禁則対応分割

**選択**: カラム分割のロジックを以下の2段階に分離する。

1. **フラット化**: セグメントリストをフラットな文字エントリリスト（各文字が元セグメントへの参照を持つ）に変換
2. **禁則対応分割**: フラット文字リストに対してカラム分割を行い、分割点で禁則ルールを適用

**代替案**:
- 現在のストリーム処理に禁則判定を埋め込む: セグメント境界をまたぐ先読みが困難で、コードが複雑化する
- 後処理方式（分割後にカラム境界を調整）: `PlainTextSegment` の分割・結合が必要になり、セグメント整合性の維持が煩雑

**理由**: フラット化することで、セグメント種別に関係なく一律に禁則判定を適用できる。`vertical_text_layout.dart` の `buildVerticalCharEntries` と類似のアプローチで、コードベースとの一貫性がある。

### 3. 禁則文字の定義：データレイヤーに新規ファイルを追加

**選択**: `lib/features/text_viewer/data/kinsoku.dart` に禁則文字セットと判定関数を配置する。

**対象文字**:

行頭禁則文字（列の先頭に配置不可）:
- 句読点: `。、，．,.`
- 閉じ括弧: `）」』】〕｝〉》﹂﹄︶﹈︸﹀︼︺︘︾)]}`
- 中点・コロン等: `・：；`
- 感嘆符・疑問符: `！？!?`
- 長音・音引き: `ー`
- リーダー: `…‥`
- 小書き仮名: `ぁぃぅぇぉっゃゅょゎァィゥェォッャュョヮヵヶ`

行末禁則文字（列の末尾に配置不可）:
- 開き括弧: `（「『【〔｛〈《﹁﹃︵﹇︷︿︻︹︗︽([{`

**理由**: `vertical_char_map.dart` と同じデータレイヤーに配置することで、文字処理関連のロジックが集約される。セット定義を分離することでテストと将来の拡張が容易。

### 4. 禁則の連鎖への対応：連続する禁則文字を全て引き込む

**選択**: 行頭禁則文字が連続する場合（例: `。」`、`！？」`）、連続する全ての行頭禁則文字を前のカラムに引き込む。単一文字ではなく、`while` ループで連続する禁則文字を処理する。

**初期設計の問題**: 当初は「最大1文字の調整に制限」としていたが、以下の理由で不十分であることが判明した。

- `。」` は小説テキストで極めて頻繁に出現する（台詞末尾: `「今日はいい天気です。」`）
- `！？」`、`。）` なども一般的なパターン
- 1文字制限では `。` のみ引き込まれ、`」` が次カラムの先頭に残る

**実装**: `splitWithKinsoku` の Case 1（カラム超過時）と Case 2（カラム満杯時）の行頭禁則処理を `if` から `while` ループに変更し、連続する行頭禁則文字を全て現在のカラムに引き込む。

**理由**: 実用上、連続する行頭禁則文字は2〜3文字（`。」`、`！？」`）であり、カラム幅への影響は最小限。正しい禁則処理のために必要な変更。

### 5. RubyTextSegmentの扱い：ルビセグメント全体を不可分として処理

**選択**: `RubyTextSegment` はフラット化の際に1つの不可分ユニットとして扱う。禁則判定にはベーステキストの先頭文字（行頭禁則）と末尾文字（行末禁則）を使用する。

**理由**: ルビ付きテキストは文字単位で分割できないため、既存の扱い（`_addRubyTextToColumns`）と一致する。

## Risks / Trade-offs

- **カラム文字数の変動**: 禁則処理によりカラムが `charsPerColumn ± 1` になる。ページネーションは幅ベースのため大きな影響はないが、カラム幅が1文字分変動することでページ分割結果が微妙に変わる可能性がある → ページネーション側は既にカラム幅を動的に計算しているため、実質的な問題は発生しない
- **テストへの影響**: 既存のカラム分割テストの期待値が変わる可能性がある → テストケースを禁則文字を含まないケースと含むケースに分けて対応
- **パフォーマンス**: フラット化ステップの追加による計算コスト → テキスト量に対して線形（O(n)）であり、現在の個別widget生成コストと比較して無視できるレベル
