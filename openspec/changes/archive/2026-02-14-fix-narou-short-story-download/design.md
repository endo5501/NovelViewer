## Context

現在の `NarouSite.parseIndex()` はHTMLからエピソードリンクを探し、`NovelIndex(title, episodes)` を返す。`DownloadService.downloadNovel()` は `novelIndex.episodes` をループしてダウンロードする。短編小説のページにはエピソードリンクが存在せず、本文がインデックスページ自体に直接含まれているため、`episodes` が空リストとなり何もダウンロードされない。

短編小説ページのHTML構造は長編のエピソードページと同じbodyセレクタ（`.js-novel-text.p-novel__text` 等）で本文が取得できる。

## Goals / Non-Goals

**Goals:**
- 短編小説（エピソード0件）をダウンロードできるようにする
- 長編と同じフォルダ構造（`narou_{ncode}/`）で保存する
- 既存の長編ダウンロードロジックに影響を与えない
- メタデータDB・ビューアは既存の仕組みをそのまま利用する

**Non-Goals:**
- カクヨムの短編対応（現時点ではスコープ外）
- 短編・長編を区別するUIの追加（ビューア上では同じ扱い）

## Decisions

### 1. 短編本文の取得方法: `NovelIndex` にボディコンテンツを追加

**選択**: `NovelIndex` に `String? bodyContent` フィールドを追加し、`parseIndex` 内でエピソードリンクが0件の場合に本文を直接抽出して格納する。

**理由**: 短編の場合、インデックスページ自体が本文ページであるため、`parseIndex` で取得済みのHTMLから本文を抽出できる。これにより追加のHTTPリクエストが不要になる。

**代替案**:
- **仮想エピソードを生成する案**: エピソード0件の場合にURLを自身に向けた仮想 `Episode` を1件作成し、既存のダウンロードループで処理させる。シンプルだが同じページを再度フェッチするため無駄なHTTPリクエストが発生する。
- **`parseIndex` の戻り値を変更せず `downloadNovel` 側で対処する案**: `downloadNovel` がHTMLを保持してエピソード0件時に再解析する。責務の分離が崩れるため不採用。

### 2. 短編のファイル名

**選択**: エピソードindex=1、タイトル=小説タイトルとして、既存の `formatEpisodeFileName` を使用する。結果: `1_{小説タイトル}.txt`

**理由**: 既存のファイル命名規則をそのまま利用でき、特別な処理が不要。totalEpisodesが1なのでパディングなし。

### 3. 短編のエピソードキャッシュ

**選択**: 短編もエピソードキャッシュに登録する。URLはインデックスページのURLを使用する。

**理由**: 再ダウンロード時に更新チェック（HEADリクエスト）が機能するようにするため。長編と同じキャッシュの仕組みをそのまま利用できる。

### 4. `downloadNovel` での短編ハンドリング

**選択**: `novelIndex.episodes` が空で `novelIndex.bodyContent` が非nullの場合、ループに入らず直接ファイル保存する分岐を追加する。

**理由**: 短編は1ページのみなので、既存のエピソードループとは別の短い処理で完結させる方が明快。プログレスコールバックは1/1で呼び出す。

## Risks / Trade-offs

- **[Risk] エピソード0件だが短編でもないページ（例: 作品が削除済み等）** → bodyContentがnullのケースとして区別される。bodyセレクタにマッチしなければ空文字が返りbodyContentは設定されないため、既存のエラーハンドリングで対応可能。
- **[Risk] 短編小説のタイトルセレクタが長編と異なる可能性** → 現在のタイトルセレクタ群（`.p-novel__title`, `.novel_title`, `#novel_title`, `h1`）は短編ページでも共通のため問題ない。
- **[Trade-off] `NovelIndex` のインターフェース変更** → `bodyContent` はオプショナルフィールドのため、既存コードへの影響は最小限。`NovelSite` インターフェースの変更は不要（`parseIndex` の戻り値型は同じ）。
