## Context

縦書きモードでは、テキストの空行が空カラムとして表現される。現在の実装では空カラムは幅ゼロとして扱われ、ページネーションでもレンダリングでも視覚的に存在しない。横書きモードでは空行が正しく表示されるため、縦書きモードとの間で一貫性がない。

関連するコード:
- `vertical_text_viewer.dart` の `_groupColumnsIntoPages` — ページネーション幅計算
- `vertical_text_page.dart` の `build()` — 改行エントリの選択的レンダリング（`_computeEmptyColumnNewlines`、先頭空カラムスペーサー）

## Goals / Non-Goals

**Goals:**
- 空カラムを通常カラムと同じ幅（1文字分）で表示し、横書きモードと一貫した空行表現を実現する
- ページネーション計算が空カラムの幅を正しく反映する

**Non-Goals:**
- 空行の幅をユーザーが設定可能にすること
- 空行の表示スタイル（背景色等）を変更すること

## Decisions

### 1. 空カラムの選択的識別とレンダリング

**選択**: 改行エントリのうち「空カラム（空行由来）」と「カラム区切り（通常の列折り返し）」を区別し、空カラム改行のみに `SizedBox(width: charWidth)` を付与する。カラム区切り改行は従来通り `SizedBox(width: 0)` を維持する。

**実装**: `_computeEmptyColumnNewlines()` メソッドで改行エントリと `buildColumnStructure()` が生成するカラム構造を照合し、空カラムに対応する改行エントリのインデックスを `Set<int>` として事前計算する。buildループでは、この集合に含まれる改行のみ `fontSize` 幅を付与する。

**理由**: 全ての改行エントリに幅を持たせると、通常のカラム区切り（長い行が複数カラムに分割される際の折り返し）にも幅が付いてしまい、テキストが大幅にオーバーフローする。空行（段落区切り）のみが可視化対象。

### 2. 先頭空カラムの明示的スペーサー

**選択**: ページの先頭カラムが空カラムの場合、改行エントリが存在しないため、明示的に `SizedBox(width: fontSize, height: double.infinity)` を `children` リストの先頭に追加する。

**理由**: 空カラムの可視化は改行エントリ経由で行うが、先頭カラムには先行する改行がないため特別な処理が必要。これがないと先頭空行が不可視になり、ページネーション計算とのずれが生じる。

### 3. ページネーション: 全カラムに共通の幅、ラン数のみ区別

**選択**: `_groupColumnsIntoPages` で `width += charWidth` を全カラム共通化し、`hasText` 分岐はWrapのラン数（テキスト列はセンチネル+文字列の2ラン、空列はセンチネルのみの1ラン）の計算にのみ使用する。

**理由**: レンダリングでは空カラムのセンチネル自体が `charWidth` を持つため、Wrapの幅消費は通常カラムと同じ。ただしWrapの「ラン」としては、空カラムはセンチネル1つのみ（通常カラムはセンチネル+文字列で2つ）なので、`runSpacing` の計算ではこの差を反映する必要がある。

### 4. デッドコードの除去

**選択**: `_buildCharWidget()` 内の `isNewline` ブランチを削除。

**理由**: buildループで改行エントリは `continue` により先に処理されるため、`_buildCharWidget` に改行が渡されることはない。到達不能コードを残すと保守時の混乱を招く。

## Risks / Trade-offs

- **ページ数の増加**: 空行が多いテキストでは1ページあたりのカラム数が減り、ページ数が増える → 小説での空行は意図的な表現なので、これは正しい動作。許容する。
- **既存テストの更新**: 空行関連のテストが現在のゼロ幅動作を前提としている → テストの期待値を新しい動作に合わせて更新する。
