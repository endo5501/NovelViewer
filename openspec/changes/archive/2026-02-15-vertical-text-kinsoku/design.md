## Context

縦書き表示のカラム分割は `vertical_text_viewer.dart` の `_splitLineIntoColumns` → `_addPlainTextToColumns` / `_addRubyTextToColumns` で行われている。現在は純粋に文字数（`charsPerColumn`）のみで分割しており、日本語組版の禁則処理が未実装。

カラム分割は `TextSegment`（`PlainTextSegment` / `RubyTextSegment`）のリストを受け取り、各セグメントを順次処理してカラム（列）を構築する。禁則判定には「次のカラムの先頭文字」や「現在のカラムの末尾文字」を参照する必要があるが、現在のストリーム処理方式ではセグメント境界をまたぐ先読みが困難。

## Goals / Non-Goals

**Goals:**

- 行頭禁則文字（句読点、閉じ括弧など）がカラムの先頭に来ないようにする
- 行末禁則文字（開き括弧など）がカラムの末尾に来ないようにする
- 禁則文字の定義をデータレイヤーに分離し、テスト可能にする
- 既存のページネーション（幅ベースパッキング）との整合性を維持する

**Non-Goals:**

- ぶら下げ組み（文字をはみ出させて配置する視覚的処理）は対象外。文字数の調整のみ行う
- 文字間の詰め処理（カーニング調整）は対象外
- 分離禁止（特定の文字列を分割しない処理）は対象外
- 横書きモードへの禁則処理適用は対象外（Flutterの標準テキストレイアウトが処理）

## Decisions

### 1. 禁則処理方式：追い出し（末尾文字を次カラムに押し出す）

**選択**: 行頭禁則文字が次のカラムの先頭に来る場合、現在のカラムの末尾文字を次のカラムの先頭に移動する（現在のカラムが1文字短くなる）。禁則文字は移動された文字の後に配置されるため、カラム先頭には来ない。行末禁則文字が現在のカラムの末尾に来る場合も同様に次のカラムの先頭に移動する。

**制約: Wrapウィジェットとの整合性**: `VerticalTextPage` は Flutter の `Wrap(direction: Axis.vertical)` でカラムをレンダリングする。Wrap は利用可能な高さ（`charsPerColumn` 文字分）を超えると自動的に改行（新カラム）を作成する。そのため、禁則処理でカラムを `charsPerColumn` より長くする「引き込み」方式は使えない。引き込むと Wrap が意図しない位置で改行し、引き込んだ禁則文字が新たなカラム先頭に来てしまう。

**代替案（不採用）**:
- 引き込み方式（禁則文字を前カラムの末尾に追加する）: カラムが `charsPerColumn` を超え、Wrap が意図しない改行を作成するため不可
- ぶら下げ方式（文字を視覚的にはみ出させる）: Wrap widgetベースのレイアウトでは実現が複雑
- 追い込み方式（前の行の文字間を詰めて吸収する）: 個別Text widgetレイアウトでは字間調整が困難

**理由**: 追い出しにより全カラムが `charsPerColumn` 以下に収まり、Wrap レイアウトとの整合性が保たれる。カラムが最大1文字短くなるだけで、レイアウトへの視覚的影響は最小限。

### 2. 実装方式：フラット文字リスト化 + 禁則対応分割

**選択**: カラム分割のロジックを以下の2段階に分離する。

1. **フラット化**: セグメントリストをフラットな文字エントリリスト（各文字が元セグメントへの参照を持つ）に変換
2. **禁則対応分割**: フラット文字リストに対してカラム分割を行い、分割点で禁則ルールを適用

**代替案**:
- 現在のストリーム処理に禁則判定を埋め込む: セグメント境界をまたぐ先読みが困難で、コードが複雑化する
- 後処理方式（分割後にカラム境界を調整）: `PlainTextSegment` の分割・結合が必要になり、セグメント整合性の維持が煩雑

**理由**: フラット化することで、セグメント種別に関係なく一律に禁則判定を適用できる。`vertical_text_layout.dart` の `buildVerticalCharEntries` と類似のアプローチで、コードベースとの一貫性がある。

### 3. 禁則文字の定義：データレイヤーに新規ファイルを追加

**選択**: `lib/features/text_viewer/data/kinsoku.dart` に禁則文字セットと判定関数を配置する。

**対象文字**:

行頭禁則文字（列の先頭に配置不可）:
- 句読点: `。、，．,.`
- 閉じ括弧: `）」』】〕｝〉》﹂﹄︶﹈︸﹀︼︺︘︾)]}`
- 中点・コロン等: `・：；`
- 感嘆符・疑問符: `！？!?`
- 長音・音引き: `ー`
- リーダー: `…‥`
- 小書き仮名: `ぁぃぅぇぉっゃゅょゎァィゥェォッャュョヮヵヶ`

行末禁則文字（列の末尾に配置不可）:
- 開き括弧: `（「『【〔｛〈《﹁﹃︵﹇︷︿︻︹︗︽([{`

**理由**: `vertical_char_map.dart` と同じデータレイヤーに配置することで、文字処理関連のロジックが集約される。セット定義を分離することでテストと将来の拡張が容易。

### 4. 連続する禁則文字への対応：追い出し方式で自然に解決

**選択**: 行頭禁則文字が連続する場合（例: `。」`、`！？」`）、追い出し方式では末尾1文字を押し出すだけで、連続する禁則文字は全て次カラムの2文字目以降に配置される。

**経緯**:
1. 初期設計では「引き込み方式・最大1文字」としたが、連続禁則に対応できなかった
2. 次に「引き込み方式・while ループで連続禁則を全て引き込む」に変更したが、Wrap が `charsPerColumn` を超えたカラムで意図しない改行を作成する根本的問題が判明
3. 最終的に「追い出し方式」に変更。末尾1文字を押し出すことで、禁則文字は自然に次カラムの2文字目以降に配置される

**実装**: `splitWithKinsoku` の行頭禁則処理で `moveLastEntryToNext()` を使用。カラムの文字数が2以上の場合のみ押し出しを行う（1文字のカラムでは押し出し不可）。

**理由**: 追い出し方式ではカラムが短くなるだけなので、Wrap の高さ制約を超えることがない。連続禁則文字は自然に次カラム内に収まる。

### 5. RubyTextSegmentの扱い：ルビセグメント全体を不可分として処理

**選択**: `RubyTextSegment` はフラット化の際に1つの不可分ユニットとして扱う。禁則判定にはベーステキストの先頭文字（行頭禁則）と末尾文字（行末禁則）を使用する。

**理由**: ルビ付きテキストは文字単位で分割できないため、既存の扱い（`_addRubyTextToColumns`）と一致する。

## Risks / Trade-offs

- **カラム文字数の変動**: 禁則処理（追い出し方式）によりカラムが `charsPerColumn - 1` になることがある。ページネーションは幅ベースのため大きな影響はないが、カラムが1文字短くなることでページ分割結果が微妙に変わる可能性がある → ページネーション側は既にカラム幅を動的に計算しているため、実質的な問題は発生しない
- **テストへの影響**: 既存のカラム分割テストの期待値が変わる可能性がある → テストケースを禁則文字を含まないケースと含むケースに分けて対応
- **パフォーマンス**: フラット化ステップの追加による計算コスト → テキスト量に対して線形（O(n)）であり、現在の個別widget生成コストと比較して無視できるレベル
