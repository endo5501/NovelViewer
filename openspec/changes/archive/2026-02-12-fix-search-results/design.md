## Context

現在の検索機能は `TextSearchService.search()` がファイルシステムの走査順で結果を返しており、ソートされていない。検索結果パネルではファイル名クリックで `selectedFileProvider` を更新してファイルを切り替えるが、行番号情報は連携されず、テキストビューアはファイル先頭を表示する。ハイライト機能も未実装。

## Goals / Non-Goals

**Goals:**
- 検索結果をファイル名順（数値プレフィックス対応）にソートする
- 検索結果のマッチ行クリック時に該当行までスクロールする
- テキストビューア上で検索クエリ文字列をハイライト表示する

**Non-Goals:**
- 検索UIの変更（入力フォーム追加など）
- インクリメンタル検索やリアルタイムフィルタリング
- マッチ間のナビゲーション（次へ/前へボタン）

## Decisions

### 1. 検索結果のソート方法

**決定**: `TextSearchService.search()` の戻り値を `FileSystemService.sortByNumericPrefix()` と同等のロジックでソートする。

**理由**: ファイルブラウザの左カラムと同じソート順を採用することで、ユーザーが一貫した並び順を期待できる。ソートは `searchResultsProvider` 内で行い、サービス層はデータ取得に専念させる。

**代替案**: `TextSearchService` 内でソートする方法も考えたが、ソートはプレゼンテーション上の関心事であり、providerレイヤーで行うのが適切。

### 2. マッチ選択状態の管理

**決定**: 新しい `selectedSearchMatchProvider` を `text_search_providers.dart` に追加する。マッチ行クリック時にファイル選択と行番号を同時に設定する。

**状態モデル**:
```dart
class SelectedSearchMatch {
  final String filePath;
  final int lineNumber;
  final String query;
}
```

**理由**: ファイルパス・行番号・検索クエリを1つの状態にまとめることで、テキストビューアが必要な情報を一箇所から取得できる。

### 3. テキストハイライトの実装方法

**決定**: `SelectableText` を `SelectableText.rich` に変更し、`TextSpan` で検索クエリにマッチする部分にハイライトスタイルを適用する。

**理由**: Flutter標準のリッチテキスト機能で実現でき、外部パッケージへの依存が不要。テキスト選択機能も維持できる。

**代替案**: `RichText` ウィジェットを使う方法もあるが、テキスト選択機能を維持するために `SelectableText.rich` が適切。

### 4. 行位置へのスクロール方法

**決定**: `ScrollController` を使用し、行番号からスクロールオフセットを算出して `animateTo()` でスクロールする。1行あたりの高さはテキストスタイルのフォントサイズと行間から計算する。

**理由**: テキストは単一の `SelectableText` で表示しており、個々の行にキーを割り当てる方法は適さない。テキストスタイルから行高さを算出するアプローチが最もシンプル。

**代替案**: `GlobalKey` を各行に割り当てて `Scrollable.ensureVisible()` を使う方法は、テキスト全体を行ごとのウィジェットに分割する必要があり、大幅な変更が必要になる。

### 5. マッチ行クリックのUI変更

**決定**: 現在テキスト表示のみのマッチ行を `InkWell` でラップし、クリック可能にする。クリック時にファイル選択と `selectedSearchMatchProvider` の更新を同時に行う。

**理由**: ファイル名クリックだけでなくマッチ行もクリック可能にすることで、ユーザーが特定のマッチ箇所に直接ジャンプできる。

## Risks / Trade-offs

- **行高さ計算の精度**: テキストスタイルからの行高さ算出は、フォントやレンダリング環境によって若干のずれが生じる可能性がある → 対象行が確実に表示範囲内に入るよう、数行分の余裕を持たせたオフセット計算とする
- **大量マッチ時のハイライトパフォーマンス**: テキスト内のすべてのマッチ箇所に `TextSpan` を生成するため、マッチ数が非常に多い場合にパフォーマンスが低下する可能性がある → 現時点では小説テキストの検索が主用途であり、問題になる可能性は低い
