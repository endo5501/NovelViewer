## Context

現在の`DownloadService.downloadNovel()`は、エピソードリスト取得後に全エピソードを順次ダウンロードする。再ダウンロード時も同じ処理が走り、数百話の小説では数分～数十分の無駄が生じる。

既存のグローバルDB（`novel_metadata.db`）は小説単位のメタデータのみを管理しており、エピソード単位の情報は保持していない。エピソードの差分管理に必要なデータは新たに追加する必要がある。

## Goals / Non-Goals

**Goals:**

- 既存エピソードの再ダウンロードを回避し、新規・更新分のみをダウンロードする
- エピソードキャッシュ情報を小説フォルダ内に保持し、フォルダ削除時に自動的にクリーンアップされるようにする
- ダウンロードの進捗表示にスキップ情報を反映する

**Non-Goals:**

- エピソード本文のキャッシュ（ローカルDBにテキスト本体を保存することはしない）
- エピソードの並び替え・挿入への完全対応（新規追加が末尾であることを前提とする）
- グローバルDB（`novel_metadata.db`）のスキーマ変更
- 強制再ダウンロード機能（将来の拡張として残す）

## Decisions

### 1. エピソードキャッシュDBの配置: 小説フォルダ内のローカルDB

**選択**: 各小説フォルダ内に`episode_cache.db`を配置する

**代替案**:
- (A) グローバルDB（`novel_metadata.db`）にエピソードテーブルを追加 → フォルダ削除時にDB側のクリーンアップが必要。小説数が増えるとテーブルが肥大化する
- (B) JSONファイルで管理 → 同時書き込み時の整合性が保証しにくい。SQLiteの方がクエリが容易

**理由**: フォルダ削除で自動クリーンアップされる。小説ごとに独立しているため、他の小説のデータに影響しない。`sqflite`は既存依存なので追加パッケージ不要。

### 2. エピソードの識別: URLベース

**選択**: エピソードURLを一意キーとして使用する

**代替案**:
- (A) エピソードインデックス（番号）で識別 → 間に新しい話が挿入された場合にインデックスがずれる
- (B) タイトルで識別 → タイトルが変更される可能性がある

**理由**: URLはサイト側で一意に付与される安定した識別子。エピソードの追加・並べ替えがあっても同一エピソードを正しく追跡できる。

### 3. 更新検出方式: HEADリクエストによるLast-Modifiedチェック

**選択**: キャッシュ済みエピソードに対してHEADリクエストを送信し、`Last-Modified`ヘッダを前回ダウンロード時の値と比較する

**フロー**:
1. インデックスページを取得してエピソードリストを取得
2. 小説フォルダ内の`episode_cache.db`を開く（なければ新規作成）
3. 各エピソードについて:
   - キャッシュにURLが存在しない → **ダウンロード**（新規エピソード）
   - キャッシュにURLが存在する → HEADリクエストで`Last-Modified`を取得
     - サーバーの`Last-Modified`がキャッシュの値より新しい → **ダウンロード**（更新あり）
     - 同じまたは古い → **スキップ**（変更なし）
     - サーバーが`Last-Modified`を返さない → **スキップ**（判定不能のため保守的にスキップ）
4. ダウンロードしたエピソードのメタデータをキャッシュDBに保存

**代替案**:
- (A) URLリスト比較のみ（HEADリクエストなし） → 既存エピソードの更新を検出できないが、高速。将来のオプションとして検討可能
- (B) 条件付きGET（If-Modified-Since） → 変更がない場合304でレスポンスが軽量だが、変更があった場合もなかった場合もGETリクエストのオーバーヘッドがある

**理由**: HEADリクエストはGETより軽量で、更新有無の判定のみに特化している。多くのエピソードが未変更の場合に効率的。

### 4. キャッシュDBスキーマ

```sql
CREATE TABLE episode_cache (
  url TEXT PRIMARY KEY,
  episode_index INTEGER NOT NULL,
  title TEXT NOT NULL,
  last_modified TEXT,
  downloaded_at TEXT NOT NULL
)
```

- `url`: エピソードページのURL（一意キー）
- `episode_index`: インデックスページでの表示順
- `title`: エピソードタイトル
- `last_modified`: HTTPレスポンスの`Last-Modified`ヘッダ値（サーバーが返さない場合はnull）
- `downloaded_at`: ダウンロード実行日時（ISO8601）

### 5. プログレス表示の拡張

**選択**: `DownloadState`に`skippedEpisodes`フィールドを追加し、UIでスキップ数を表示する

**表示例**: 「5/100 (スキップ: 90件)」— 処理済み5件中、実際にダウンロードしたのは5件、90件はスキップ

### 6. アーキテクチャ構成

新規追加するコンポーネント:
- `EpisodeCacheDatabase`: 小説フォルダ内のSQLiteデータベース管理（開閉・テーブル作成）
- `EpisodeCacheRepository`: エピソードキャッシュのCRUD操作
- `EpisodeCache`: エピソードキャッシュのドメインモデル

既存コンポーネントへの変更:
- `DownloadService`: ダウンロードループにキャッシュチェック・HEADリクエストロジックを追加。`fetchHead`メソッドを新規追加
- `DownloadState`: `skippedEpisodes`フィールドを追加
- `DownloadNotifier`: キャッシュリポジトリの生成・注入を追加
- `DownloadDialog`: プログレス表示にスキップ数を反映

ファイル配置:
```
lib/features/episode_cache/
  ├── data/
  │   ├── episode_cache_database.dart
  │   └── episode_cache_repository.dart
  ├── domain/
  │   └── episode_cache.dart
  └── providers/
      └── episode_cache_providers.dart
```

## Risks / Trade-offs

- **[サーバーがLast-Modifiedを返さない場合]** → 保守的にスキップする。内容が変更されていても検出できないが、Web小説の既存エピソードが更新されるケースは稀。将来的に強制再ダウンロードオプションで対応可能
- **[HEADリクエストによるサーバー負荷]** → スキップ対象のエピソードにもHEADリクエストを送信するため、リクエスト数自体は削減されない。ただしデータ転送量は大幅に削減される。リクエスト間の遅延（700ms）は維持する
- **[エピソードの並び替え・挿入]** → URLベースで追跡するため、同一エピソードは正しく認識されるが、ファイル名のインデックスが変わる可能性がある。その場合、古いファイルが残る可能性がある。稀なケースのため初期実装では対応しない
- **[DBファイルの破損]** → DBファイルが破損した場合、全エピソードが再ダウンロードされる（キャッシュなし状態にフォールバック）。データ喪失のリスクはない
